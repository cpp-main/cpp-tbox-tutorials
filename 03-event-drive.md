# 事件驱动模式的编程

在上面的教程中，我们创建了第一个自己模块`MyModule`，我们只需要重写它的`onInit()`,`onStart()`,`onStop()`,`onCleanup()`就可以实现所有的业务功能。这对第一次接触网络编程的同学会比较陌生。  

在传统的开发中，我们是需要创建很多线程来实现与外部交互的功能的。  
比如：读写串口，我们要创建两个线程。其中一个专门负责读串口设备文件，将读到的数据写入到一个读队列里，再由业务线程去处理。再创建一个线程，负责从发送队列里取出要发送数据，并写到串口设备文件中。如果同时管理N个串口，那么就需要创建2N个线程。如果是一个网络通信的服务程序，要为每一个socket创建一个读线程。  
这无疑增加了内存资源与CPU资源的消耗，同时要管理多线程之间的资源访问，避免竞态。如果在加锁上出现纰漏，多线程出现访问竞态，会出现很多偶发性bug，很不好查。采用这样的编程模式会很令人心身疲惫。

tbox采用的是传统的网络编程模式：Reactor。关于 Reactor 我们可以在网上找到很多资料，笔者就不再在此赘述了。  
tbox.main 框架主要借鉴了 [Node.js](https://nodejs.org/zh-cn) 的思想。采用：**Reactor线程 + 线程池** 的结构。  

- Reactor线程：采用多路复用模型，处理所有的事件；
- 线程池：辅助执行阻塞性的函数调用、与大运算；

Reactor线程就像是一个银行的办事柜台。如果遇到很轻松就能完成的事务，比如查询余额，柜台工作人员就立即处理了。如果遇到的是比较繁重的工作，比如大额的取款，柜台工作人员便令后面的工作人员进行操作，让顾客在休息区等待。柜台工作人员则继续接待其它的顾客。等后面的工作人员取出了大金额的现金后，柜台工作人员呼叫取钱的顾客，并将现金给到该顾客。  
这个过程中，柜台工作人员就是Reactor线程，后面的工作人员就是线程池的工作线程。查询余额则是非阻塞性任务，取大额现金则是阻塞性的任务。

在 tbox.main 框架编程中，一切都是基于事件驱动的。具体操作就是：向Reactor注册某个事件的回调函数。当该事件发生了，Reactor就会回调之前注册的函数。  
这种模型对注册的回调函数有三个基本的要求：**不要阻塞！不要阻塞！不要阻塞！**。  
大家可以拜读一下 Node.js 的官方文档《[不要阻塞事件循环](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop)》，咱们的 cpp-tbox 与 Node.js 的机制是一样的，原理也是相通的。

基于这个要求：

- 所有的回调事务要尽快完成，时间消耗要限制在1ms以内；
- 不要执行读写文件的操作，如果需要，移交给线程池去做；
- 不要进行大规模运算，如果需要，移交给线程池去做。

-------
[[返回主页]](README.md)
